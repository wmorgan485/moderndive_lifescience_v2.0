# Data Wrangling {#wrangling}

```{r setup_wrangling, include=FALSE, purl=FALSE}
# Used to define Learning Check numbers:
chap <- 3
lc <- 0

# Set R code chunk defaults:
opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  warning = FALSE,
  message = TRUE,
  tidy = FALSE,
  purl = TRUE,
  out.width = "\\textwidth",
  fig.height = 4,
  fig.align = "center"
)

# Set output digit precision
options(scipen = 99, digits = 3)

# In kable printing replace all NA's with blanks:
options(knitr.kable.NA = "")

# Set random number generator seed value for replicable pseudorandomness:
set.seed(76)
```

So far in our journey, we've seen how to look at data saved in data frames (Chapter \@ref(getting-started)) and how to create data visualizations using the grammar of graphics, which maps variables in a data frame to the aesthetic attributes of `geom`etric objects (Chapter \@ref(viz)).

Recall that for some of our visualizations, we first needed to transform/modify existing data frames a little. For example, to create the linegraph in Figure \@ref(fig:dailyweight) with measurements *only* for Chick 1, we first needed to pare down the `ChickWeight` data frame to a `chick1_weight` data frame consisting of only `Chick == 1` rows. Thus, `chick1_weight` will have fewer rows than `ChickWeight`. We did this using the `filter()` function:

```{r, eval=FALSE}
chick1_weight <- filter(ChickWeight, Chick == 1)
```

In this chapter, we'll extend this example and we'll introduce a series of functions from the `dplyr` package for data wrangling that will allow you to take a data frame and "wrangle" it (transform it) to suit your needs. Such functions include:

1. `filter()` and `slice` a data frame's existing rows to only pick out a subset of rows. 
1. `select()` a data frame's existing columns to only keep a subset or `rename` existing columns. 
1. `summarize()` one or more of a data frame's columns/variables with a *summary statistic*. Examples of summary statistics include the median and interquartile range of chick weights as we saw in Section \@ref(boxplots) on boxplots. 
1. `group_by()` the rows of a data frame. In other words, assign different rows to be part of the same *group*. We can then combine `group_by()` with `summarize()` to report summary statistics for each group *separately*. For example, say you don't want a single overall average `weight` on Day 21 for the `chick_weight_d21` dataset, but rather four separate averages, one computed for each of the four `Diet` groups.
1. `mutate()` a data frame's existing columns/variables to create new ones. For example, convert weight recordings from grams to ounces.
1. `arrange()` a data frame's rows in a new order. For example, sort the rows of `mammals` in ascending or descending order of `life_span`.

Notice how we used `computer_code` font to describe the actions we want to take on our data frames. This is because the `dplyr` package for data wrangling has intuitively verb-named functions that are easy to remember. 

There is a further benefit to learning to use the `dplyr` package for data wrangling: its similarity to the database querying language [SQL](https://en.wikipedia.org/wiki/SQL) (pronounced "sequel" or spelled out as "S", "Q", "L"). SQL (which stands for "Structured Query Language") is used to manage large databases quickly and efficiently and is widely used by many institutions with a lot of data. While SQL is a topic left for a book or a course on database management, keep in mind that once you learn `dplyr`, you can learn SQL easily. 


```{block loa3, type="review", purl=FALSE}
\vspace{-0.15in}

**_Chapter Learning Objectives_**

*At the end of this chapter, you should be able to…*  
• Use pipes to make it easier to create and read complex code.  
• Use data wrangling functions to rearrange a data frame, retrieve a subset of rows or columns, and create new variables.  
• Calculate summary statistics, such as mean and median, for separate groups.  
\vspace{-0.1in}
```


### Needed packages {-#wrangling-packages}

Let's load all the packages needed for this chapter (this assumes you've already installed them). If needed, read Section \@ref(packages) for information on how to install and load R packages.

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(openintro)
```

```{r message=FALSE, warning=FALSE, echo=FALSE, purl=FALSE}
# Packages needed internally, but not in text.
library(kableExtra)
library(readr)
library(stringr)
library(scales)
```





## The pipe operator: `%>%` {#piping}

Before we start data wrangling, let's first introduce a nifty tool that gets loaded with the `dplyr` package: the \index{operators!pipe} pipe operator `%>%` (also indicated as `|>`). The pipe operator allows us to combine multiple operations in R into a single sequential *chain* of actions.

Let's start with a hypothetical example. Say you would like to perform a hypothetical sequence of operations on a hypothetical data frame `x` using hypothetical functions `f()`, `g()`, and `h()`:

1. Take `x` *then*
1. Use `x` as an input to a function `f()` *then*
1. Use the output of `f(x)` as an input to a function `g()` *then*
1. Use the output of `g(f(x))` as an input to a function `h()`

One way to achieve this sequence of operations is by using nesting parentheses as follows:

```{r, eval=FALSE, purl=FALSE}
h(g(f(x)))
```

This code isn't so hard to read since we are applying only three functions: `f()`, then `g()`, then `h()` and each of the functions is short in its name. Further, each of these functions also only has one argument. However, you can imagine that this will get progressively harder to read as the number of functions applied in your sequence increases and the arguments in each function increase as well. This is where the pipe operator `%>%` comes in handy. `%>%` takes the output of one function and then "pipes" it to be the input of the next function. Furthermore, a helpful trick is to read `%>%` as "then" or "and then." For example, you can obtain the same output as the hypothetical sequence of functions as follows:

```{r, eval=FALSE, purl=FALSE}
x %>% 
  f() %>% 
  g() %>% 
  h()
```

You would read this sequence as:

1. Take `x` *then*
1. Use this output as the input to the next function `f()` *then*
1. Use this output as the input to the next function `g()` *then*
1. Use this output as the input to the next function `h()`

So while both approaches achieve the same goal, the latter is much more human-readable because you can clearly read the sequence of operations line-by-line. But what are the hypothetical `x`, `f()`, `g()`, and `h()`?  Throughout this chapter on data wrangling:

1. The starting value `x` will be a data frame. For example, the `mammals` data frame we explored in Section \@ref(mammalsdataframe).
1. The sequence of functions, here `f()`, `g()`, and `h()`, will mostly be a sequence of any number of the data wrangling, verb-named functions we listed in the introduction to this chapter. For example, the `filter(Chick == 1)` function and argument we previewed earlier.
1. The result will be the transformed/modified data frame that you want. In our example, we'll save the result in a new data frame by using the `<-` assignment operator with the name `chick1_weight` via `chick1_weight <-`.

```{r, eval=FALSE}
chick1_weight <- ChickWeight %>% 
  filter(Chick == 1)
```

Much like when adding layers to a `ggplot()` using the `+` sign, you form a single *chain* of data wrangling operations by combining verb-named functions into a single sequence using the pipe operator `%>%`. Furthermore, much like how the `+` sign has to come at the end of lines when constructing plots, the pipe operator `%>%` has to come at the end of lines as well. 

Keep in mind, there are many more advanced data wrangling functions than just those listed in the introduction to this chapter. However, just with these verb-named functions you'll be able to perform a broad array of data wrangling tasks for the rest of this book.





## `filter` rows {#filter}

```{r filter, fig.cap="Diagram of filter() rows operation.", echo=FALSE, purl=FALSE}
include_graphics("images/cheatsheets/filter.png")
```

The \index{dplyr!filter} `filter()` function here works much like the "Filter" option in Microsoft Excel; it allows you to specify criteria about the values of a variable in your dataset and then filters out only the rows that match that criteria.

We begin by focusing only on mammalian species in `predation`category 1.  Run the following and look at the results in RStudio's spreadsheet viewer to ensure that only species in `predation`category 1 are chosen 

```{r, eval=FALSE}
predation1 <- mammals %>% 
  filter(predation == 1)
View(predation1)
```

Note the order of the code. First, take the `mammals` data frame; *then* `filter()` the data frame so that only those where `predation` equals `1` are included. We test for equality using the double equal sign \index{operators!==} `==` and not a single equal sign `=`. In other words `filter(predation = 1)` will yield an error. This is a convention across many programming languages. If you are new to coding, you'll probably forget to use the double equal sign `==` a few times before you get the hang of it.

You can use other operators \index{operators} beyond just the `==` operator that tests for equality:

- `>` corresponds to "greater than"
- `<` corresponds to "less than"
- `>=` corresponds to "greater than or equal to"
- `<=` corresponds to "less than or equal to"
- `!=` corresponds to "not equal to." The `!` is used in many programming languages to indicate "not."

Furthermore, you can combine multiple criteria using operators that make comparisons:

- `|` corresponds to "or"
- `&` corresponds to "and"

To see many of these in action, let's filter `mammals` for mammalian species that are in `predation` category 1 or 2 *and* not in `exposure` category 1.  Note that this example uses the \index{operators!not} `!` "not" operator to pick rows that *don't* match a criteria. As mentioned earlier, the `!` can be read as "not." Run the following:


```{r, eval=FALSE}
predation_notexp1 <- mammals %>% 
  filter((predation == 1 | predation == 2) & exposure != 1)
predation_notexp1
```


```{r echo=FALSE, purl=FALSE}
predation_notexp1 <- mammals %>% 
  filter((predation == 1 | predation == 2) & exposure != 1)
predation_notexp1
```

As expected, the `predation_notexp1` data frame contains a subset, `r nrow(predation_notexp1)` rows, of the `r nrow(mammals)` rows in the original `mammals` data frame.

This alternative code where we do *not* select species that are `exposure` category 1 achieves the same aim:

```{r, eval=FALSE}
predation_notexp1 <- mammals %>% 
  filter((predation == 1 | predation == 2) & !exposure == 1)
predation_notexp1
```

Note that even though colloquially speaking one might say "all mammalian species that are `predation` category 1 *and* 2," in terms of computer operations, we really mean "all mammalian species  that are `predation` category 1 *or* 2." For a given row in the data, `predation` can be `1`, or `2`, or something else, but not both `1` and `2` at the same time. 

We can often skip the use of `&` and just separate our conditions with a comma. The following code will return the identical output `predation_notexp1` as the previous code:

```{r, eval=FALSE}
predation_notexp1 <- mammals %>% 
  filter((predation == 1 | predation == 2), !exposure == 1)
predation_notexp1
```

Now say we have a larger number of categories we want to filter for, say a subset of species such as `"Africanelephant"`, `"Asianelephant"`, `"Deserthedgehog"`, and `"Europeanhedgehog"`. We could continue to use the `|` (*or*) \index{operators!or} operator:

```{r, eval=FALSE}
many_species <- mammals %>% 
  filter(species == "Africanelephant" | species == "Asianelephant" | species == "Deserthedgehog" | species == "Europeanhedgehog")
```

but as we progressively include more categories, this will get unwieldy to write. A slightly shorter approach uses the `%in%` \index{operators!in} operator along with the `c()` function. Recall from Subsection \@ref(programming-concepts) that the `c()` function "combines" or "concatenates" values into a single *vector* of values. \index{vectors}

```{r}
many_species <- mammals %>% 
  filter(species %in% c("Africanelephant", "Asianelephant", "Deserthedgehog", "Europeanhedgehog"))
many_species
```

This code filters `mammals` for all mammalian species where `species` is in the vector of `species` `c("Africanelephant", "Asianelephant", "Deserthedgehog", "Europeanhedgehog")`. Both outputs of `many_species` are the same, but as you can see the latter takes much less energy to code. The `%in%` operator is useful for looking for matches commonly in one vector/variable compared to another.

As a final note, we recommend that `filter()` should be among the first verbs you consider applying to your data. This cleans your dataset to only those rows you care about, or put differently, it narrows down the scope of your data frame to just the observations you care about. 

```{block lc-filter, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Adapt the previous code using the "not" operator `!` to filter only the species that are not `danger` category 4 or 5 in the `mammals` data frame.

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```


## `slice` rows

Similar to `filter`, the `slice` function  \index{dplyr!slice()} function returns a subset of rows from a data frame. While `filter` returns the rows that match a specified criteria about the values of a variable (e.g., `species == "Cat"`), the `slice` function returns rows based on their positions.  For example, let's `slice` the first 5 rows of the `mammals` data frame:

```{r, eval=FALSE}
mammals %>% slice(1:5)
```

However, even more useful is a derivative of `slice` called `slice_max` that allow us to retrieve rows with the top values of a specified variable. For example, we can return a data frame of the 5 mammalian species with the longest life spans. Observe that we set the number of values to return to `n = 5` and `order_by = life_span` to indicate that we want the rows corresponding to the top 5 values of `life_span`. 

```{r, eval=FALSE}
mammals %>% slice_max(n = 5, order_by = life_span)
```

See the help file for `slice()` by running `?slice` for more information about its related functions. 

```{block lc-other-verbs, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Repeat the previous command substituting the function `slice_head` for `slice_max`. How does the output differ?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Create a new data frame `notLongLife` that shows the rows of the `mammals` data frame with the 5 smallest values of the `life_span` variable. (Check the `slice()` help file for hints.)

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```






## `select` variables {#select}

```{r echo=FALSE, purl=FALSE}
# This redundant code is used for dynamic non-static in-line text output purposes
# :: operator used as output was wrong otherwise
mammalsdata_cols <- mammals %>%
  ncol() 
```

We recommended that you consider applying the `filter()` function to your data to narrow down the scope of your data frame to just the observations you care about. It may also be the case that you are only interested in a subset of the variables in your dataset. For example, the `mammals` data frame has `r mammalsdata_cols` variables, but typically only a few variables will be of interest for a particular analysis. You can identify the names of these `r mammalsdata_cols` variables by running the `glimpse()` function from the `dplyr` package:

```{r, eval=FALSE}
glimpse(mammals)
```

In the same way that `filter` and `slice` return a subset of rows, the `select` function and its selection helpers allow us to return a subset of columns from a data frame as illustrated in Figure \@ref(fig:selectfig).

```{r selectfig, fig.cap="Diagram of select() columns.", echo=FALSE, purl=FALSE}
include_graphics("images/cheatsheets/select.png")
```

Returning to `many_species`, our data frame with four mammalian species, we might only really be interested in the variables `species`, `body_wt` and `danger`. However, with the current data frame, it's a bit difficult to compare these columns among all the others:  

```{r}
many_species
```

Examining these columns is much easier if we work with a smaller data frame by `select()`ing \index{dplyr!select()} the desired variables:

```{r}
slim_many_species <- many_species %>% 
  select(species, body_wt, danger)
```

This slimmer data frame makes it easy to verify that we correctly `filtered` for `species` and also helps us to see the various ways that body weight relates to the danger faced by each species from other animals:


```{r}
slim_many_species
```

Let's say instead you want to drop, or de-select, certain variables. For example, perhaps you want to drop the `gestation` variable. We can deselect `gestation` by using the `-` sign:

```{r, eval=FALSE}
mammals_10cols <- mammals %>% select(-gestation)
```

Another way of selecting columns/variables is by specifying a range of columns. For example, we might want to only focus on the sleep-related variables for the mammalian species:

```{r}
mammals_sleep <- mammals %>% select(species, non_dreaming:total_sleep)
mammals_sleep
```

The `select()` function can also be used to reorder columns when combined with the `everything()` helper function.  For example, suppose we want the `species` and sleep-related variables to appear first, while not discarding the rest of the variables. In the following code, `everything()` will pick up all remaining variables: 

```{r, eval=FALSE}
mammals_reorder <- mammals %>% select(species, non_dreaming:total_sleep, everything())
glimpse(mammals_reorder)
```

See the help file for `select()` by running `?select` for more information about other selection helpers. 

```{block lc-select, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Run the code `mammals %>% select(ends_with("wt"))` to select columns with names that end with "wt". How many columns are returned? 

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Use the `contains()` helper function to select columns from the `mammals` data frame that contain "dream". How many columns are returned? 

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** What if you forgot to include the double-quotes for the first command above? Run the code `mammals %>% select(ends_with(wt))` to see what happens.

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```

The last command shows an example of what happens when you forget to include double-quotes. 
If you see an `Error` message about an `object ... not found`, try adding double-quotes to see if that fixes the problem.

### `rename` variables {#rename}

Another useful function similar to `select()` is \index{dplyr!rename()} `rename()`, which as you may have guessed changes the name of specified variables. Suppose we want to rename the `danger` variable to something more understandable, such as `danger_faced`:

```{r, eval=FALSE}
mammals %>% 
  rename(danger_faced = danger)
```

Only the name of the specified variable has changed, and all of the other variables remain intact and unchanged. Note that here we used a single `=` sign within the `rename()`. For example, `danger_faced = danger` renames the `danger` variable to have the new name `danger_faced`. This is because we are not testing for equality like we would using `==`. Instead we want to assign a new variable `danger_faced` to have the same values as `danger` and then delete the variable `danger`. 

Tip: New `dplyr` users often forget that the new variable name comes before the equal sign, followed by the old variable. You can remember this as "New Before Old". Tip 2: Avoid spaces and special symbols in your variable names, which in our experience can cause problems in R.

Pro-tip: We can also rename variables as we `select()` them from a data frame:

```{r}
mammals %>% 
  select(species, danger_faced = danger)
```

Here we selected two columns from `mammals`, changing the name of the second one in the process.




## `summarize` variables {#summarize}

Another common task when working with data frames is to compute *summary statistics*. \index{summary statistics}Summary statistics are single numerical values that summarize a large number of values. Commonly known examples of summary statistics include the mean (also called the average) and the median (the middle value). Other examples of summary statistics that might not immediately come to mind include the *sum*, the smallest value also called the *minimum*, the largest value also called the *maximum*, and the *standard deviation*, a measure of the variability or "spread" in the values. See Appendix \@ref(appendix-stat-terms) for a glossary of such summary statistics.

Let's calculate two summary statistics of the `life_span` variable in the `mammals` data frame: the mean and standard deviation. To compute these summary statistics, we need the `mean()` and `sd()` *summary functions* in R. Summary functions in R take in many values and return a single value, as illustrated in Figure \@ref(fig:summary-function). 

```{r summary-function, fig.cap="Diagram illustrating a summary function in R.", echo=FALSE, purl=FALSE, fig.height=1.5}
include_graphics("images/cheatsheets/summary.png")
options(knitr.kable.NA = "NA")
```

More precisely, we'll use the `mean()` and `sd()` summary functions within the `summarize()` \index{dplyr!summarize()} function from the `dplyr` package. Note you can also use the British English spelling of `summarise()`. As shown in Figure \@ref(fig:sum1), the `summarize()` function takes in a data frame and returns a data frame with only one row corresponding to the summary statistics. 

```{r sum1, fig.cap="Diagram of summarize() rows.", echo=FALSE, purl=FALSE, out.height="80%", out.width="80%"}
include_graphics("images/cheatsheets/summarize1.png")
```

We'll save the results in a new data frame called `summary_mammals` that will have two columns/variables: the `mean` and the `std_dev`:

```{r}
summary_mammals <- mammals %>% 
  summarize(mean = mean(life_span), std_dev = sd(life_span))
summary_mammals
```

Why are the values returned `NA`? As we saw in Subsection \@ref(geompoint), `NA` is how R encodes *missing values* \index{missing values}. By default any time you try to calculate a summary statistic of a variable that has one or more `NA` missing values in R, `NA` is returned. To work around this fact, you can set the `na.rm` argument of each summary function to `TRUE`, where `rm` is short for "remove"; this will ignore any `NA` missing values and only return the summary value for all non-missing values. 

The code that follows computes the mean and standard deviation of all non-missing values of `life_span`:

```{r}
summary_mammals <- mammals %>% 
  summarize(mean = mean(life_span, na.rm = TRUE), 
            std_dev = sd(life_span, na.rm = TRUE))
summary_mammals
```

Notice how the `na.rm = TRUE` \index{functions!na.rm argument} are used as arguments to the `mean()` \index{mean()} and `sd()` \index{sd()} summary functions individually, and not to the `summarize()` function. 

However, one needs to be cautious whenever ignoring missing values. In the upcoming *Learning checks* questions, we'll consider the possible ramifications of blindly sweeping rows with missing values "under the rug." This is in fact why the `na.rm` argument to any summary statistic function in R is set to `FALSE` by default. In other words, R does not ignore rows with missing values by default. R is alerting you to the presence of missing data and you should be mindful of this absence and any potential causes of this absence throughout your analysis.

What are other summary functions we can use inside the `summarize()` verb to compute summary statistics? As seen in the diagram in Figure \@ref(fig:summary-function), you can use any summary function in R that takes many values and returns just one. Here are just a few:

* `mean()`: the average
* `sd()`: the standard deviation, which is a measure of spread
* `min()` and `max()`: the minimum and maximum values, respectively
* `IQR()`: interquartile range
* `sum()`: the total amount when adding multiple numbers
* `n()`: a count of the number of rows in each group. This particular summary function will make more sense when `group_by()` is covered in Section \@ref(groupby).

In Section \@ref(mutate), we will introduce the `skim()` function, which can save you a lot of time writing code to calculate the most common summary statistics.

```{block lc-summarize, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** A doctor is studying the effect of smoking on lung cancer for a large number of patients who have records measured at five-year intervals. She notices that a large number of patients have missing data points because the patient has died, so she chooses to ignore these patients in her analysis. What is wrong with this doctor's approach?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Modify the earlier `summarize()` function code that creates the `summary_mammals` data frame to also use the `n()` summary function: `summarize(... , count = n())`. What does the returned value correspond to?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Why doesn't the following code work?  Run the code line-by-line instead of all at once, and then look at the data.  In other words, run `summary2_mammals <- mammals %>% summarize(mean = mean(life_span, na.rm = TRUE))` first.

```{r eval=FALSE}
summary2_mammals <- mammals %>%   
  summarize(mean = mean(life_span, na.rm = TRUE)) %>% 
  summarize(std_dev = sd(life_span, na.rm = TRUE))
```

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```



## `group_by` rows {#groupby}

<!-- To get `_` to work in caption title. Found at https://github.com/rstudio/bookdown/issues/209 -->
(ref:groupby) Diagram of group_by() and summarize().

```{r groupsummarize, fig.cap="(ref:groupby)", echo=FALSE, purl=FALSE, fig.height=2.5}
include_graphics("images/cheatsheets/group_summary.png")
```

Above we calculated the mean `life_span` of `mammals`.  Say instead of a single mean `life_span` for a dataset, we would like to compute the mean life_spans of species in different predation categories separately, that is, the mean `life_span` split by `predation`. We can do this by "grouping" the `life_span` observations by the values of another variable, in this case by the values of the variable `predation`. Run the following code:

<!--
New dplyr warning message when running group_by() %>% summarize() that is not
addressed in v1 (print edition). 
See https://github.com/moderndive/ModernDive_book/issues/353

For now we suppress this message in the book by setting 
options(dplyr.summarise.inform = FALSE) in index.Rmd

v2 TODO: Address this warning message explicitly in text and fix index.Rmd
-->
```{r}
summary_pred_life <- mammals %>% 
  group_by(predation) %>% 
  summarize(mean = mean(life_span, na.rm = TRUE), 
            std_dev = sd(life_span, na.rm = TRUE))
summary_pred_life
```

This code is similar to the code that created `summary_mammals`, but with an extra `group_by()` command added before the `summarize()`. Grouping the `mammals` dataset by `predation` and then applying the `summarize()` functions yields a data frame that displays the mean and standard deviation length split by the different predation categories.

It is important to note that the \index{dplyr!group\_by()} `group_by()` function doesn't change data frames by itself. Rather it changes the *meta-data*\index{meta-data}, or data about the data, specifically the grouping structure. It is only after we apply the `summarize()` function that the data frame changes. 

For example, let's consider the \index{ggplot2!mammals} `mammals` data frame again. Run this code:

```{r}
mammals
```

Observe that the first line of the output reads ``# A tibble: `r mammals %>% nrow() %>% comma()` x `r mammals %>% ncol()` ``. This is an example of meta-data, in this case the number of observations/rows and variables/columns in `mammals`. The actual data itself are the subsequent table of values. Now let's pipe the `mammals` data frame into `group_by(predation)`:

```{r}
mammals %>% 
  group_by(predation)
```

```{r echo=FALSE, purl=FALSE}
# This code is used for dynamic non-static in-line text output purposes
DP_levels <- mammals %>%
  select(predation) %>%
  n_distinct()
```

Observe that now there is additional meta-data: ``# Groups: predation [`r DP_levels`]`` indicating that the grouping structure meta-data has been set based on the `r DP_levels` possible levels of the categorical variable `predation`. On the other hand, observe that the data has not changed: it is still a table of `r mammals %>% nrow() %>% comma()` $\times$ `r mammals %>% ncol()` values.

Only by combining a `group_by()` with another data wrangling operation, in this case `summarize()`, will the data actually be transformed. 

```{r}
mammals %>% 
  group_by(predation) %>% 
  summarize(avg_life = mean(life_span, na.rm = TRUE))
```

If you would like to remove this grouping structure meta-data, we can pipe the resulting data frame into the \index{dplyr!ungroup()} `ungroup()` function:

```{r}
mammals %>% 
  group_by(predation) %>% 
  ungroup()
```

Observe how the ``# Groups: predation [`r DP_levels`]`` meta-data is no longer present. 

Let's now revisit the `n()` \index{dplyr!n()} counting summary function we briefly introduced previously. Recall that the `n()` function counts rows. This is opposed to the `sum()` summary function that returns the sum of a numerical variable. For example, suppose we'd like to count how many mammalian species were in each `predation` group:

```{r}
by_pred <- mammals %>% 
  group_by(predation) %>% 
  summarize(count = n())
by_pred
```

We see that the greatest number of species are in `predation` category 2 and the fewest in category 4. 


### Grouping by more than one variable

You are not limited to grouping by one variable. Say you want to know the number of species of each `predation` category for each `exposure` level. We can also group by this second variable using `group_by(predation, exposure)`:

```{r message=FALSE, warning=FALSE}
by_pred_exp <- mammals %>% 
  group_by(predation, exposure) %>% 
  summarize(count = n())
by_pred_exp
```

Why do we `group_by(predation, exposure)` and not `group_by(predation)` and then `group_by(exposure)`? Let's investigate:

```{r message=FALSE, warning=FALSE}
by_pred_exp_incorrect <- mammals %>% 
  group_by(predation) %>% 
  group_by(exposure) %>% 
  summarize(count = n())
by_pred_exp_incorrect
```

What happened here is that the second `group_by(exposure)` overwrote the grouping structure meta-data of the earlier `group_by(predation)`, so that in the end we are only grouping by `exposure`. The lesson here is if you want to `group_by()` two or more variables, you should include all the variables at the same time in the same `group_by()` adding a comma between the variable names.

```{block lc-groupby, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Examining the `summary_pred_life` data frame, in which predation category do mammalian species have the longest average life span? Which predation category shows the greatest variation in life spans?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** What code would be required to get the mean and standard deviation of `life_span` for each `danger` level of `mammals`?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** Recreate `by_pred_exp`, but instead of grouping via `group_by(predation, exposure)`, group variables in the reverse order `group_by(exposure, predation)`. What differs in the resulting dataset?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** How could we identify how many mammalian species are in each `danger` level?

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** How does the `filter()` operation differ from a `group_by()` followed by a `summarize()`?

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```





## `mutate` existing variables {#mutate}

```{r select, fig.cap="Diagram of mutate() columns.", echo=FALSE, purl=FALSE, out.height='80%', out.width='80%'}
include_graphics("images/cheatsheets/mutate.png")
```

Another common transformation of data is to create/compute new variables based on existing ones. For example, say you are more comfortable thinking of weight in pounds (lb) instead of kilograms (kg). The formula to convert weights from kg to lb is

$$
\text{weight in lb} = {\text{weight in kg}} \cdot {2.205}
$$

We can apply this formula to the `body_wt` variable using the `mutate()` \index{dplyr!mutate()} function from the `dplyr` package, which takes existing variables and mutates them to create new ones. 

```{r, eval=TRUE}
mammals <- mammals %>% 
  mutate(wt_in_lb = body_wt * 2.205)
mammals
```

In this code, we `mutate()` the `mammals` data frame by creating a new variable `wt_in_lb = body_wt * 2.205` and then *overwrite* the original `mammals` data frame. Why did we overwrite the data frame `mammals`, instead of assigning the result to a new data frame like `mammals_new`? As a rough rule of thumb, as long as you are not losing original information that you might need later, it's acceptable practice to overwrite existing data frames with updated ones, as we did here. On the other hand, why did we not overwrite the variable `body_wt`, but instead created a new variable called `wt_in_lb`?  Because if we did this, we would have erased the original information contained in `body_wt` of weights in grams that may still be valuable to us.

Let's now compute average body weights of mammalian species in different `predation` categories in both kg and lb using the `group_by()` and `summarize()` code we saw in Section \@ref(groupby):

```{r}
summary_pred_wt <- mammals %>% 
  group_by(predation) %>% 
  summarize(mean_wt_in_kg = mean(body_wt, na.rm = TRUE), 
            mean_wt_in_lb = mean(wt_in_lb, na.rm = TRUE))
summary_pred_wt
```


Let's look at some summary statistics of the `wt_in_lb` variable by considering multiple summary functions at once in the same `summarize()` code:

```{r}
lb_summary <- mammals %>% 
  summarize(
    min = min(wt_in_lb, na.rm = TRUE),
    q1 = quantile(wt_in_lb, 0.25, na.rm = TRUE),
    median = quantile(wt_in_lb, 0.5, na.rm = TRUE),
    q3 = quantile(wt_in_lb, 0.75, na.rm = TRUE),
    max = max(wt_in_lb, na.rm = TRUE),
    mean = mean(wt_in_lb, na.rm = TRUE),
    sd = sd(wt_in_lb, na.rm = TRUE),
    missing = sum(is.na(wt_in_lb))
  )
lb_summary
```

We see for example that the mean weight for all mammalian species is about `r lb_summary$mean %>% round()` pounds, while the heaviest species is `r lb_summary$max %>% round() %>% comma()` pounds! 

However, typing out all these summary statistic functions in `summarize()` is long and tedious. Fortunately, there is a much more succinct way to compute a variety of common summary statistics using the `skim()` function from the `skimr` \index{R packages!skimr!skim()} package. This function takes in a data frame, "skims" it, and returns commonly used summary statistics. 

Let's select the `wt_in_lb` column from `mammals` and pipe it into the `skim()` function:


```{r eval=FALSE}
mammals %>% select(wt_in_lb) %>% skim()
```
<!--
TODO: 
Update skimr::skim() output to match v2.0.1

Skipped: Couldn't figure out how to use skim_with(ts = sfl(line_graph = NULL))
at https://cran.r-project.org/web/packages/skimr/vignettes/skimr.html

Used remotes::install_version("skimr", version = "1.0.6") to use that version
instead.

(For formatting purposes in this book, the inline histogram that is usually printed with `skim()` has been removed. This can be done by using `skim_with(numeric = list(hist = NULL))` prior to using the `skim()` function for version 1.0.6 of `skimr`.)
-->

For the numerical variable `wt_in_lb`, `skim()` returns:

- `n_missing`: the number of missing values
- `complete_rate`: the proportion of complete values
- `mean`: the average
- `sd`: the standard deviation
- `p0`: the 0th percentile: the value at which 0% of observations are smaller than it (the *minimum* value)
- `p25`: the 25th percentile: the value at which 25% of observations are smaller than it (the *1st quartile*)
- `p50`: the 50th percentile: the value at which 50% of observations are smaller than it (the *2nd* quartile and more commonly called the *median*)
- `p75`: the 75th percentile: the value at which 75% of observations are smaller than it (the *3rd quartile*)
- `p100`: the 100th percentile: the value at which 100% of observations are smaller than it (the *maximum* value)

Recall from Section \@ref(histograms) that since `wt_in_lb` is a numerical variable, we can visualize its distribution using a histogram.  

```{r depth-range-hist, fig.cap="Histogram of wt_in_lb variable.", message=FALSE, fig.height=3}
ggplot(data = mammals, mapping = aes(x = wt_in_lb)) +
  geom_histogram(color = "white", boundary = 0, binwidth = 200)
```

The resulting histogram in Figure \@ref(fig:depth-range-hist) provides a different perspective on the `wt_in_lb` variable than the summary statistics we computed earlier. For example, note that most values of `wt_in_lb` are right around 0. 

To close out our discussion on the `mutate()` function to create new variables, note that we can create multiple new variables at once in the same `mutate()` code. Furthermore, within the same `mutate()` code we can refer to new variables we just created, as shown in this example:

```{r}
mammals <- mammals %>% 
  mutate(
    wt_in_oz = wt_in_lb * 16,
    oz_per_year = wt_in_oz / life_span
  )
```

```{block lc-mutate, type="learncheck", purl=FALSE}
\vspace{-0.15in}
**_Learning check_**
\vspace{-0.1in}
```

**`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`** What can we say about the distribution of `wt_in_lb`?  Describe it in a few sentences using the plot and the `lb_summary` data frame values.

```{block, type="learncheck", purl=FALSE}
\vspace{-0.25in}
\vspace{-0.25in}
```





## `arrange` and sort rows {#arrange}

One of the most commonly performed data wrangling tasks is to sort a data frame's rows in the alphanumeric order of one of the variables. The `dplyr` package's `arrange()` function \index{dplyr!arrange()} allows us to sort/reorder a data frame's rows according to the values of the specified variable.

Suppose we are interested in determining the `predation` level most common among mammalian species:

```{r}
freq_pred <- mammals %>% 
  group_by(predation) %>% 
  summarize(num_species = n())
freq_pred
```

Observe that by default the rows of the resulting `freq_pred` data frame are sorted in numerical order of `predation` category. Say instead we would like to see the same data, but sorted from the most to the least number of species (`num_species`) instead:

```{r}
freq_pred %>% 
  arrange(num_species)
```

This is, however, the opposite of what we want. The rows are sorted with the least frequently preferred habitats displayed first. This is because `arrange()` always returns rows sorted in ascending order by default. To switch the ordering to be in "descending" order instead, we use the `desc()` \index{dplyr!desc()} function as so:

```{r}
freq_pred %>% 
  arrange(desc(num_species))
```






## Conclusion {#wrangling-conclusion}

### Summary table

Let's recap our data wrangling verbs in Table \@ref(tab:wrangle-summary-table). Using these verbs and the pipe `%>%` operator from Section \@ref(piping), you'll be able to write easily legible code to perform almost all the data wrangling and data transformation necessary for the rest of this book. 

```{r wrangle-summary-table, message=FALSE, echo=FALSE, purl=FALSE}

if (!file.exists("rds/ch4_scenarios.rds")) {
  ch4_scenarios <-
    "./data/ch5_summary_table - Sheet1.csv" %>%
    read_csv(na = "") %>%
    select(-1)
  write_rds(ch4_scenarios, "rds/ch4_scenarios.rds")
} else {
  ch4_scenarios <- read_rds("rds/ch4_scenarios.rds")
}

if (is_latex_output()) {
  ch4_scenarios %>%
    # Weird tick marks show up in PDF:
    mutate(
      Verb = str_replace_all(Verb, "`", ""),
      `Data wrangling operation` = str_replace_all(`Data wrangling operation`, "`", ""),
    ) %>%
    kable(
      caption = "Summary of data wrangling verbs",
      booktabs = TRUE,
      linesep = "",
      format = "latex"
    ) %>%
    kable_styling(
      font_size = ifelse(is_latex_output(), 10, 16),
      latex_options = c("hold_position")
    ) %>%
    column_spec(1, width = "0.9in") %>%
    column_spec(2, width = "4in")
} else {
  ch4_scenarios %>%
    kable(
      caption = "Summary of data wrangling verbs",
      booktabs = TRUE,
      format = "html"
    )
}
```


### Additional resources
<!--
```{r results="asis", echo=FALSE, purl=FALSE}
if(is_latex_output()){
  cat("Solutions to all *Learning checks* can be found online in [Appendix D](https://moderndive.com/D-appendixD.html).")
}
```

```{r results="asis", echo=FALSE, purl=FALSE}
generate_r_file_link("03-wrangling.R")
```
-->

If you want to further unlock the power of the `dplyr` package for data wrangling, we suggest that you check out RStudio's "Data Transformation with dplyr" cheatsheet. This cheatsheet summarizes much more than what we've discussed in this chapter, including more advanced data wrangling functions, while providing quick and easy-to-read visual descriptions. You can access this cheatsheet by going to the RStudio Menu Bar and selecting "Help -> Cheatsheets -> Data Transformation with dplyr." 

On top of the data wrangling verbs and examples we presented in this section, if you'd like to see more examples of using the `dplyr` package for data wrangling, check out [Chapter 5](http://r4ds.had.co.nz/transform.html) of *R for Data Science* [@rds2016].


### What's to come?

So far in this book, we've explored, visualized, and wrangled data saved in data frames. These data frames were saved in a spreadsheet-like format: in a rectangular shape with a certain number of rows corresponding to observations and a certain number of columns corresponding to variables describing these observations. 

We'll see in the upcoming Chapter \@ref(tidy) that there are actually two ways to represent data in spreadsheet-type rectangular format: (1) "wide" format and (2) "tall/narrow" format. The tall/narrow format is also known as *"tidy"* format in R user circles. While the distinction between "tidy" and non-"tidy" formatted data is subtle, it has immense implications for our data science work. This is because almost all the packages used in this book, including the `ggplot2` package for data visualization and the `dplyr` package for data wrangling, assume that all data frames are in "tidy" format. 

